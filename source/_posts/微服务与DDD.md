---
title: 微服务与DDD
date: 2018-01-19 11:12:34
tags:
- 微服务
- DDD
- CRQS
- 一致性
---

　　大家好，我先介绍一下我自己，我是 EDP 项目的首席拖拽师，Smart、MBE 的前端程序员，今天能给大家分享一下后端特别高大上的技能，**微服务**与DDD（Domain Driven Design）。

　　相信大家之前一定听说过微服务和 DDD，只要一说微服务就会想起DDD，一说到DDD 人们马上就会联想到微服务，那它们到底有什么关系呢？今天我可以坚强勇敢的告诉大家——**它们没关系！**

### DDD 的历史

　　我们先来看一下 DDD 的历史，在 2004 年著名的建模专家 Eric Evans 发表了著作[《Domain-DrivenDesign–TacklingComplexityintheHeartofSoftware》](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)，中文译[《领域驱动设计》](https://book.douban.com/subject/26819666/)，不仅仅在计算机领域，在其他领域涉及到建模都可以借鉴书中的思路，这么伟大一本著作 2004 年就发表了，但一直都没火，没火的原因就是太抽象和枯燥，枯燥到什么程度呢——就连我都没读过。

　　过了将近十年，又出现了一个老外 Vaughn Vernon 在2013 年写了一本[《Implementing Domain-Driven Design》](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577),中文译[《实现领域驱动设计》](https://book.douban.com/subject/25844633/)。

### 微服务的历史

　　我们再来看一下**微服务**的历史，2014 年，Marting Fowler 与 James Lewis 共同提出了微服务的概念，定义了微服务是由以单一应用程序构成的小服务，拥有独立运行独立部署的能力等等。

　　这个时候，好多公司才意识到原来自己做了这么多年，这东西叫**微服务**！这个故事告诉我们：你做了多久都没用，能归纳总结出概念的人才是**牛人**！

### 究竟啥关系

　　可见微服务与DDD的确没关系哈，那什么时候又扯上关系的呢，当人们在做微服务的时候发现很多概念和思路与DDD 的思想非常契合，用DDD 是思想实践微服务更加的合理。之后DDD这一伟大的思想才被推广起来，所以也可以说是**微服务**拯救了DDD。

　　倘若真扯上点关系，我们可以理解 DDD 是实践微服务的指导思想，通过 DDD 的设计原则实践的微服务会更加的合理。

### 如何实践？

#### 通用语言(Ubiquitous Language)

　　你有没有发现，开发的工作其实就是一个翻译的过程，将程序员的语言翻译给机器让机器为我们工作，而 BA（产品经理）则是将业务语言翻译成程序员能够理解的语言，让我们能够听懂，这个过程中不仅是一种浪费，更会影响程序员对业务的理解。

　　如果领域专家会写程序一定会比任何人更接近真实的业务系统，遗憾的是他不能，否则我们就要失业了。

　　过去的开发方式还存在一个风险，当开发这个程序的程序员离职了，后面交接的人很难真正理解这些复杂的代码。新同学不仅要学习业务知识，还要找到业务与代码的联系，而代码并不能表达清楚业务含义。

　　现在我们可以通过 DDD 的指导思想，将**通用语言**和行为映射到我们的程序中，举个例子，看过《鬼吹灯》的同学可能会知道，陪葬品在考古学家的领域叫古董，在盗墓贼的领域中叫“冥器”，从海里捞出来的叫“青头”。

再看一个例子。在餐饮行业中，服务员将菜品从后厨放到顾客的桌台上，并在菜品小票上划一下，这一系列动作称为**传菜和划菜**。我们则需要在系统中做成同样的动作。

```java
public class Food {
  private String status;
  public void setStatus () { ... }
}
public class 小票 {
  public List<菜品> 小票上的菜品；
  public void setFoodStatus(int 菜品序号) {
  	小票上的菜品.get(菜品序号).setStatus('served')；
  }
}

```



``` java
public class Food {
  private String status;
  public void haveBeenServed () {
  	this.status = 'served';
  }
}
public class 小票 {
  public List<菜品> 小票上的菜品；
  public void 划菜(菜品序号) {
  	小票上的菜品.get(菜品序号).haveBeenServed();
  }
}

```

*（这两段代码力度不够…还需要找到更有力的示例）*

　　使代码成为业务的说明。

在项目前期可以通过 **Event Storming** 与领域专家一起举行 workshop，来帮助我们快速学习业务。

#### 服务划分

　　通常开始一个新的项目的时候使用“**大泥球**”（也就是俗称的**单体项目**），当然也会在项目初期根据职能去拆服务，这样划分通常是粗粒度的，仍然属于“**大泥球**”。随着业务慢慢发展，**人员**不断扩张才会开始进行服务拆分，这个时候拆分也会更加合理。

　　有一个国外的老头在1967年提出了一个著名的定律：**[康威定律](https://en.wikipedia.org/wiki/Conway%27s_law)**。按照我们现在的理解，系统架构则是现实组织架构的一种映射。

![康威定律](http://insights.thoughtworks.cn/wp-content/uploads/2017/10/3-Service-boundaries-reinforced-by-team-boundaries-700x397.png)

##### 过早的划分

　　那有没有项目初期将粒度拆的非常小的呢？我个人并不建议这样做，过早的进行拆分很容易导致划分不合理，导致了很多跨服务的修改，而这些修改修改的代价相当高。尤其是对于创业项目，这样的玩票是极其危险的。

> 在[《Building Microservices》](https://www.amazon.com/Building-Microservices-Designing-Fine-Grained-Systems/dp/1491950358)（中文译[《微服务设计》](https://book.douban.com/subject/26772677/)）一书中也有提到，他们将服务过早划分带来了巨大是修改成本，团队又将这些服务合并成了一个单体系统，从而给所有人时间去理解服务边界到底在哪。一年之后，团队识别出了非常稳定的边界，并据此将这个单块系统拆分成多个微服务。

　　当两个的变更周期（一个服务的修改总是带动另一个服务变更）基本相同，我们就应该考虑是否划分存在问题。

#### 跨服务的 Join

　　在划分服务之后我们最先面临的一个问题就是数据的 join，简单的查询我们通常可以直接调用多个服务，在 BFF（[Backends For Frontends](https://samnewman.io/patterns/architectural/bff/)） 中进行聚合。但难免会有复杂的列表查询：

*假设一个电商平台将 **卖家**、**订单**、**买家** 分为3 个服务，在**卖家**后台可以看到所有的**订单**列表及订单的**买家**信息，每页20条。*

过去我们可以通过 SQL 语句轻松搞定：

```sql
SELECT * FROM 订单 LEFT JOIN 买家 ON 订单.买家ID = 买家.ID WHERE 订单.ID = "XXX" ORDER BY 订单.下单时间 DESC LIMIT 0, 20;
```

然而现在问题复杂了，我们需要先查询出**卖家**的20条**订单**，然后再调用20次**买家**的接口将数据聚合，如果还有**库存**、**物流**信息那么这个调用就变的相当复杂，这显然不是我们能够接受的。

{% asset_img 1.png 需求 %}

##### CQRS(Command Query Responsibility Segregation)

　　CQRS 翻译成中文：**命令与查询职责分离**，Command 是指：增、删、改，Query 是：查询，并不是我们常说的主从读写分离，一图胜千言，如图：

{% asset_img 2.png 视图数据库 %}

　　在向**订单**和**买家**进行更新操作时需要发布一个事件，通过订阅事件来更新**视图数据库**，以满足我们跨服务查询的需求。

##### 数据一致性

　　紧接着我们还看到一个问题，当创建**订单**的同时锁定**库存**，库存很有可能会空，当锁定库存失败则需要**回滚**创建订单，复杂情况还可能造成死锁。划分服务之后又面临一个跨服务分布式事务问题。

> **回滚** 就像是计算机领域中的黑魔法，并不是一种正常手段，在分布式环境中我们要忘记这个词。已经发生的事件是永远不可能恢复到发生之前，就好比我给你发了一条短信，没有办法被撤回，想要对方不处理这条短信的方式只能再发一条短信告知对方请无视之前的消息，这条才是真正的内容。

　　分布式事务是将所有的操作异步化，达到**最终一致性**。达到最终一致性我们需要增加一些中间状态。

{% asset_img 3.png 事务 %}

　　现实情况要更为复杂：

1. 下订单与发消息是原子操作，避免在订单成功确没有发出去消息。
2. 在锁定库存之后订单服务可能会挂掉，所以需要超时来保证库存不会永久锁定，同时发布锁定库存取消事件。
3. 消息重试机制，在订单服务恢复时处理。
4. 消息持久化，在消息送到消息服务器后，而消息服务自己挂了，避免消息丢失需要进行持久化
